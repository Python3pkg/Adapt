# Generated from bsdl.g by ANTLR 4.5.3
# encoding: utf-8
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3y")
        buf.write("\u00de\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\3\2\3\2\3\2\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\6\3*\n\3\r\3\16\3+\3\3\3\3\3\3\3\3\3\3\7\3\63")
        buf.write("\n\3\f\3\16\3\66\13\3\3\3\3\3\5\3:\n\3\3\3\3\3\7\3>\n")
        buf.write("\3\f\3\16\3A\13\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\5\7c\n\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7n\n\7\5\7p\n\7\3\b\3")
        buf.write("\b\3\t\6\tu\n\t\r\t\16\tv\3\n\3\n\3\n\3\n\3\n\3\n\3\n")
        buf.write("\3\n\3\13\3\13\3\13\3\13\3\13\7\13\u0086\n\13\f\13\16")
        buf.write("\13\u0089\13\13\3\13\3\13\3\13\3\f\3\f\3\f\7\f\u0091\n")
        buf.write("\f\f\f\16\f\u0094\13\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\6\f")
        buf.write("\u009d\n\f\r\f\16\f\u009e\3\f\3\f\6\f\u00a3\n\f\r\f\16")
        buf.write("\f\u00a4\3\f\5\f\u00a8\n\f\3\r\3\r\7\r\u00ac\n\r\f\r\16")
        buf.write("\r\u00af\13\r\3\r\3\r\6\r\u00b3\n\r\r\r\16\r\u00b4\7\r")
        buf.write("\u00b7\n\r\f\r\16\r\u00ba\13\r\3\16\3\16\3\17\3\17\7\17")
        buf.write("\u00c0\n\17\f\17\16\17\u00c3\13\17\3\17\3\17\3\20\7\20")
        buf.write("\u00c8\n\20\f\20\16\20\u00cb\13\20\3\20\3\20\7\20\u00cf")
        buf.write("\n\20\f\20\16\20\u00d2\13\20\3\20\3\20\5\20\u00d6\n\20")
        buf.write("\3\20\7\20\u00d9\n\20\f\20\16\20\u00dc\13\20\3\20\2\2")
        buf.write("\21\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36\2\6\3\2tu\3")
        buf.write("\2wx\3\2wy\7\2 !\66\6688<<LL\u00e4\2 \3\2\2\2\4#\3\2\2")
        buf.write("\2\6F\3\2\2\2\bQ\3\2\2\2\nV\3\2\2\2\fo\3\2\2\2\16q\3\2")
        buf.write("\2\2\20t\3\2\2\2\22x\3\2\2\2\24\u0080\3\2\2\2\26\u0092")
        buf.write("\3\2\2\2\30\u00a9\3\2\2\2\32\u00bb\3\2\2\2\34\u00c1\3")
        buf.write("\2\2\2\36\u00c9\3\2\2\2 !\5\4\3\2!\"\7\2\2\3\"\3\3\2\2")
        buf.write("\2#$\7+\2\2$%\5\30\r\2%)\79\2\2&\'\5\6\4\2\'(\7\r\2\2")
        buf.write("(*\3\2\2\2)&\3\2\2\2*+\3\2\2\2+)\3\2\2\2+,\3\2\2\2,-\3")
        buf.write("\2\2\2-.\5\24\13\2.\64\7\r\2\2/\60\5\b\5\2\60\61\7\r\2")
        buf.write("\2\61\63\3\2\2\2\62/\3\2\2\2\63\66\3\2\2\2\64\62\3\2\2")
        buf.write("\2\64\65\3\2\2\2\65?\3\2\2\2\66\64\3\2\2\2\67:\5\n\6\2")
        buf.write("8:\5\22\n\29\67\3\2\2\298\3\2\2\2:;\3\2\2\2;<\7\r\2\2")
        buf.write("<>\3\2\2\2=9\3\2\2\2>A\3\2\2\2?=\3\2\2\2?@\3\2\2\2@B\3")
        buf.write("\2\2\2A?\3\2\2\2BC\7*\2\2CD\5\30\r\2DE\7\r\2\2E\5\3\2")
        buf.write("\2\2FG\7\61\2\2GH\7\n\2\2HI\5\30\r\2IJ\7\f\2\2JK\5\30")
        buf.write("\r\2KL\7\f\2\2LM\7\16\2\2MN\5\34\17\2NO\3\2\2\2OP\7\13")
        buf.write("\2\2P\7\3\2\2\2QR\7l\2\2RS\5\30\r\2ST\7\20\2\2TU\7\27")
        buf.write("\2\2U\t\3\2\2\2VW\7\34\2\2WX\5\30\r\2XY\7G\2\2YZ\5\30")
        buf.write("\r\2Z[\7\f\2\2[\\\5\f\7\2\\\13\3\2\2\2]^\7+\2\2^b\79\2")
        buf.write("\2_c\5\30\r\2`c\5\34\17\2ac\5\20\t\2b_\3\2\2\2b`\3\2\2")
        buf.write("\2ba\3\2\2\2cp\3\2\2\2de\7^\2\2em\79\2\2fn\5\16\b\2gh")
        buf.write("\7\n\2\2hi\5\36\20\2ij\7\17\2\2jk\7v\2\2kl\7\13\2\2ln")
        buf.write("\3\2\2\2mf\3\2\2\2mg\3\2\2\2np\3\2\2\2o]\3\2\2\2od\3\2")
        buf.write("\2\2p\r\3\2\2\2qr\t\2\2\2r\17\3\2\2\2su\7y\2\2ts\3\2\2")
        buf.write("\2uv\3\2\2\2vt\3\2\2\2vw\3\2\2\2w\21\3\2\2\2xy\7%\2\2")
        buf.write("yz\5\30\r\2z{\7\f\2\2{|\5\30\r\2|}\7\f\2\2}~\7\16\2\2")
        buf.write("~\177\5\34\17\2\177\23\3\2\2\2\u0080\u0081\7N\2\2\u0081")
        buf.write("\u0087\7\n\2\2\u0082\u0083\5\26\f\2\u0083\u0084\7\r\2")
        buf.write("\2\u0084\u0086\3\2\2\2\u0085\u0082\3\2\2\2\u0086\u0089")
        buf.write("\3\2\2\2\u0087\u0085\3\2\2\2\u0087\u0088\3\2\2\2\u0088")
        buf.write("\u008a\3\2\2\2\u0089\u0087\3\2\2\2\u008a\u008b\5\26\f")
        buf.write("\2\u008b\u008c\7\13\2\2\u008c\25\3\2\2\2\u008d\u008e\5")
        buf.write("\30\r\2\u008e\u008f\7\17\2\2\u008f\u0091\3\2\2\2\u0090")
        buf.write("\u008d\3\2\2\2\u0091\u0094\3\2\2\2\u0092\u0090\3\2\2\2")
        buf.write("\u0092\u0093\3\2\2\2\u0093\u0095\3\2\2\2\u0094\u0092\3")
        buf.write("\2\2\2\u0095\u0096\5\30\r\2\u0096\u0097\7\f\2\2\u0097")
        buf.write("\u00a7\5\32\16\2\u0098\u00a8\7\21\2\2\u0099\u009a\7\22")
        buf.write("\2\2\u009a\u009c\7\n\2\2\u009b\u009d\7y\2\2\u009c\u009b")
        buf.write("\3\2\2\2\u009d\u009e\3\2\2\2\u009e\u009c\3\2\2\2\u009e")
        buf.write("\u009f\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0\u00a2\7f\2\2")
        buf.write("\u00a1\u00a3\7y\2\2\u00a2\u00a1\3\2\2\2\u00a3\u00a4\3")
        buf.write("\2\2\2\u00a4\u00a2\3\2\2\2\u00a4\u00a5\3\2\2\2\u00a5\u00a6")
        buf.write("\3\2\2\2\u00a6\u00a8\7\13\2\2\u00a7\u0098\3\2\2\2\u00a7")
        buf.write("\u0099\3\2\2\2\u00a8\27\3\2\2\2\u00a9\u00ad\t\3\2\2\u00aa")
        buf.write("\u00ac\t\4\2\2\u00ab\u00aa\3\2\2\2\u00ac\u00af\3\2\2\2")
        buf.write("\u00ad\u00ab\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ae\u00b8\3")
        buf.write("\2\2\2\u00af\u00ad\3\2\2\2\u00b0\u00b2\7\t\2\2\u00b1\u00b3")
        buf.write("\t\4\2\2\u00b2\u00b1\3\2\2\2\u00b3\u00b4\3\2\2\2\u00b4")
        buf.write("\u00b2\3\2\2\2\u00b4\u00b5\3\2\2\2\u00b5\u00b7\3\2\2\2")
        buf.write("\u00b6\u00b0\3\2\2\2\u00b7\u00ba\3\2\2\2\u00b8\u00b6\3")
        buf.write("\2\2\2\u00b8\u00b9\3\2\2\2\u00b9\31\3\2\2\2\u00ba\u00b8")
        buf.write("\3\2\2\2\u00bb\u00bc\t\5\2\2\u00bc\33\3\2\2\2\u00bd\u00be")
        buf.write("\7\5\2\2\u00be\u00c0\7\b\2\2\u00bf\u00bd\3\2\2\2\u00c0")
        buf.write("\u00c3\3\2\2\2\u00c1\u00bf\3\2\2\2\u00c1\u00c2\3\2\2\2")
        buf.write("\u00c2\u00c4\3\2\2\2\u00c3\u00c1\3\2\2\2\u00c4\u00c5\7")
        buf.write("\5\2\2\u00c5\35\3\2\2\2\u00c6\u00c8\7y\2\2\u00c7\u00c6")
        buf.write("\3\2\2\2\u00c8\u00cb\3\2\2\2\u00c9\u00c7\3\2\2\2\u00c9")
        buf.write("\u00ca\3\2\2\2\u00ca\u00cc\3\2\2\2\u00cb\u00c9\3\2\2\2")
        buf.write("\u00cc\u00d0\7\20\2\2\u00cd\u00cf\7y\2\2\u00ce\u00cd\3")
        buf.write("\2\2\2\u00cf\u00d2\3\2\2\2\u00d0\u00ce\3\2\2\2\u00d0\u00d1")
        buf.write("\3\2\2\2\u00d1\u00d3\3\2\2\2\u00d2\u00d0\3\2\2\2\u00d3")
        buf.write("\u00d5\7\3\2\2\u00d4\u00d6\7\4\2\2\u00d5\u00d4\3\2\2\2")
        buf.write("\u00d5\u00d6\3\2\2\2\u00d6\u00da\3\2\2\2\u00d7\u00d9\7")
        buf.write("y\2\2\u00d8\u00d7\3\2\2\2\u00d9\u00dc\3\2\2\2\u00da\u00d8")
        buf.write("\3\2\2\2\u00da\u00db\3\2\2\2\u00db\37\3\2\2\2\u00dc\u00da")
        buf.write("\3\2\2\2\27+\649?bmov\u0087\u0092\u009e\u00a4\u00a7\u00ad")
        buf.write("\u00b4\u00b8\u00c1\u00c9\u00d0\u00d5\u00da")
        return buf.getvalue()


class bsdlParser ( Parser ):

    grammarFileName = "bsdl.g"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'e'", "'+'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'&'", "'_'", "'('", "')'", "':'", "';'", 
                     "'='", "','", "'.'", "'bit'", "'bit_vector'", "'abs'", 
                     "'access'", "'after'", "'alias'", "'all'", "'and'", 
                     "'architecture'", "'array'", "'assert'", "'attribute'", 
                     "'begin'", "'block'", "'body'", "'buffer'", "'bus'", 
                     "'case'", "'component'", "'configuration'", "'constant'", 
                     "'disconnect'", "'downto'", "'else'", "'elsif'", "'end'", 
                     "'entity'", "'exit'", "'file'", "'for'", "'function'", 
                     "'generate'", "'generic'", "'group'", "'guarded'", 
                     "'if'", "'impure'", "'in'", "'inertial'", "'inout'", 
                     "'is'", "'label'", "'library'", "'linkage'", "'literal'", 
                     "'loop'", "'map'", "'mod'", "'nand'", "'new'", "'next'", 
                     "'nor'", "'not'", "'null'", "'of'", "'on'", "'open'", 
                     "'or'", "'others'", "'out'", "'package'", "'port'", 
                     "'postponed'", "'procedure'", "'process'", "'pure'", 
                     "'range'", "'record'", "'register'", "'reject'", "'rem'", 
                     "'report'", "'return'", "'rol'", "'ror'", "'select'", 
                     "'severity'", "'signal'", "'shared'", "'sla'", "'sll'", 
                     "'sra'", "'srl'", "'subtype'", "'then'", "'to'", "'transport'", 
                     "'type'", "'unaffected'", "'units'", "'until'", "'use'", 
                     "'variable'", "'wait'", "'when'", "'while'", "'with'", 
                     "'xnor'", "'xor'", "'true'", "'false'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "STRING", "WHITESPACE", 
                      "COMMENT", "ANDSIGN", "USCORE", "OPAREN", "CPAREN", 
                      "COLON", "SCOLON", "EQUAL", "COMMA", "DOT", "BIT", 
                      "BIT_VECTOR", "ABS", "ACCESS", "AFTER", "ALIAS", "ALL", 
                      "AND", "ARCHITECTURE", "ARRAY", "ASSERT", "ATTRIBUTE", 
                      "BEGIN", "BLOCK", "BODY", "BUFFER", "BUS", "CASE", 
                      "COMPONENT", "CONFIGURATION", "CONSTANT", "DISCONNECT", 
                      "DOWNTO", "ELSE", "ELSIF", "END", "ENTITY", "EXIT", 
                      "FILE", "FOR", "FUNCTION", "GENERATE", "GENERIC", 
                      "GROUP", "GUARDED", "IF", "IMPURE", "IN", "INERTIAL", 
                      "INOUT", "IS", "LABEL", "LIBRARY", "LINKAGE", "LITERAL", 
                      "LOOP", "MAP", "MOD", "NAND", "NEW", "NEXT", "NOR", 
                      "NOT", "NULL", "OF", "ON", "OPEN", "OR", "OTHERS", 
                      "OUT", "PACKAGE", "PORT", "POSTPONED", "PROCEDURE", 
                      "PROCESS", "PURE", "RANGE", "RECORD", "REGISTER", 
                      "REJECT", "REM", "REPORT", "RETURN", "ROL", "ROR", 
                      "SELECT", "SEVERITY", "SIGNAL", "SHARED", "SLA", "SLL", 
                      "SRA", "SRL", "SUBTYPE", "THEN", "TO", "TRANSPORT", 
                      "TYPE", "UNAFFECTED", "UNITS", "UNTIL", "USE", "VARIABLE", 
                      "WAIT", "WHEN", "WHILE", "WITH", "XNOR", "XOR", "TRUE", 
                      "FALSE", "BOTH", "WORD", "FULLCASE_WORD", "DIGIT" ]

    RULE_evaluate = 0
    RULE_entity = 1
    RULE_generic = 2
    RULE_use = 3
    RULE_attribute = 4
    RULE_general_attribute_assignment = 5
    RULE_boolean = 6
    RULE_number = 7
    RULE_constant = 8
    RULE_port_list = 9
    RULE_port_def = 10
    RULE_identifier = 11
    RULE_portmode = 12
    RULE_string = 13
    RULE_scinot_number = 14

    ruleNames =  [ "evaluate", "entity", "generic", "use", "attribute", 
                   "general_attribute_assignment", "boolean", "number", 
                   "constant", "port_list", "port_def", "identifier", "portmode", 
                   "string", "scinot_number" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    STRING=3
    WHITESPACE=4
    COMMENT=5
    ANDSIGN=6
    USCORE=7
    OPAREN=8
    CPAREN=9
    COLON=10
    SCOLON=11
    EQUAL=12
    COMMA=13
    DOT=14
    BIT=15
    BIT_VECTOR=16
    ABS=17
    ACCESS=18
    AFTER=19
    ALIAS=20
    ALL=21
    AND=22
    ARCHITECTURE=23
    ARRAY=24
    ASSERT=25
    ATTRIBUTE=26
    BEGIN=27
    BLOCK=28
    BODY=29
    BUFFER=30
    BUS=31
    CASE=32
    COMPONENT=33
    CONFIGURATION=34
    CONSTANT=35
    DISCONNECT=36
    DOWNTO=37
    ELSE=38
    ELSIF=39
    END=40
    ENTITY=41
    EXIT=42
    FILE=43
    FOR=44
    FUNCTION=45
    GENERATE=46
    GENERIC=47
    GROUP=48
    GUARDED=49
    IF=50
    IMPURE=51
    IN=52
    INERTIAL=53
    INOUT=54
    IS=55
    LABEL=56
    LIBRARY=57
    LINKAGE=58
    LITERAL=59
    LOOP=60
    MAP=61
    MOD=62
    NAND=63
    NEW=64
    NEXT=65
    NOR=66
    NOT=67
    NULL=68
    OF=69
    ON=70
    OPEN=71
    OR=72
    OTHERS=73
    OUT=74
    PACKAGE=75
    PORT=76
    POSTPONED=77
    PROCEDURE=78
    PROCESS=79
    PURE=80
    RANGE=81
    RECORD=82
    REGISTER=83
    REJECT=84
    REM=85
    REPORT=86
    RETURN=87
    ROL=88
    ROR=89
    SELECT=90
    SEVERITY=91
    SIGNAL=92
    SHARED=93
    SLA=94
    SLL=95
    SRA=96
    SRL=97
    SUBTYPE=98
    THEN=99
    TO=100
    TRANSPORT=101
    TYPE=102
    UNAFFECTED=103
    UNITS=104
    UNTIL=105
    USE=106
    VARIABLE=107
    WAIT=108
    WHEN=109
    WHILE=110
    WITH=111
    XNOR=112
    XOR=113
    TRUE=114
    FALSE=115
    BOTH=116
    WORD=117
    FULLCASE_WORD=118
    DIGIT=119

    def __init__(self, input:TokenStream):
        super().__init__(input)
        self.checkVersion("4.5.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class EvaluateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(bsdlParser.EOF, 0)

        def entity(self):
            return self.getTypedRuleContext(bsdlParser.EntityContext,0)


        def getRuleIndex(self):
            return bsdlParser.RULE_evaluate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvaluate" ):
                listener.enterEvaluate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvaluate" ):
                listener.exitEvaluate(self)




    def evaluate(self):

        localctx = bsdlParser.EvaluateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_evaluate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 30
            self.entity()
            self.state = 31
            self.match(bsdlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EntityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ename = None # IdentifierContext
            self.g = None # GenericContext

        def ENTITY(self):
            return self.getToken(bsdlParser.ENTITY, 0)

        def IS(self):
            return self.getToken(bsdlParser.IS, 0)

        def port_list(self):
            return self.getTypedRuleContext(bsdlParser.Port_listContext,0)


        def SCOLON(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.SCOLON)
            else:
                return self.getToken(bsdlParser.SCOLON, i)

        def END(self):
            return self.getToken(bsdlParser.END, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bsdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(bsdlParser.IdentifierContext,i)


        def use(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bsdlParser.UseContext)
            else:
                return self.getTypedRuleContext(bsdlParser.UseContext,i)


        def generic(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bsdlParser.GenericContext)
            else:
                return self.getTypedRuleContext(bsdlParser.GenericContext,i)


        def attribute(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bsdlParser.AttributeContext)
            else:
                return self.getTypedRuleContext(bsdlParser.AttributeContext,i)


        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bsdlParser.ConstantContext)
            else:
                return self.getTypedRuleContext(bsdlParser.ConstantContext,i)


        def getRuleIndex(self):
            return bsdlParser.RULE_entity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntity" ):
                listener.enterEntity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntity" ):
                listener.exitEntity(self)




    def entity(self):

        localctx = bsdlParser.EntityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_entity)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 33
            self.match(bsdlParser.ENTITY)
            self.state = 34
            localctx.ename = self.identifier()
            self.state = 35
            self.match(bsdlParser.IS)
            self.state = 39 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 36
                localctx.g = self.generic()
                self.state = 37
                self.match(bsdlParser.SCOLON)
                self.state = 41 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==bsdlParser.GENERIC):
                    break

            self.state = 43
            self.port_list()
            self.state = 44
            self.match(bsdlParser.SCOLON)
            self.state = 50
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bsdlParser.USE:
                self.state = 45
                self.use()
                self.state = 46
                self.match(bsdlParser.SCOLON)
                self.state = 52
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 61
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bsdlParser.ATTRIBUTE or _la==bsdlParser.CONSTANT:
                self.state = 55
                token = self._input.LA(1)
                if token in [bsdlParser.ATTRIBUTE]:
                    self.state = 53
                    self.attribute()

                elif token in [bsdlParser.CONSTANT]:
                    self.state = 54
                    self.constant()

                else:
                    raise NoViableAltException(self)

                self.state = 57
                self.match(bsdlParser.SCOLON)
                self.state = 63
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 64
            self.match(bsdlParser.END)
            self.state = 65
            self.identifier()
            self.state = 66
            self.match(bsdlParser.SCOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GenericContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.gk = None # IdentifierContext
            self.gv = None # StringContext

        def GENERIC(self):
            return self.getToken(bsdlParser.GENERIC, 0)

        def OPAREN(self):
            return self.getToken(bsdlParser.OPAREN, 0)

        def CPAREN(self):
            return self.getToken(bsdlParser.CPAREN, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.COLON)
            else:
                return self.getToken(bsdlParser.COLON, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bsdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(bsdlParser.IdentifierContext,i)


        def EQUAL(self):
            return self.getToken(bsdlParser.EQUAL, 0)

        def string(self):
            return self.getTypedRuleContext(bsdlParser.StringContext,0)


        def getRuleIndex(self):
            return bsdlParser.RULE_generic

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneric" ):
                listener.enterGeneric(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneric" ):
                listener.exitGeneric(self)




    def generic(self):

        localctx = bsdlParser.GenericContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_generic)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 68
            self.match(bsdlParser.GENERIC)
            self.state = 69
            self.match(bsdlParser.OPAREN)

            self.state = 70
            localctx.gk = self.identifier()
            self.state = 71
            self.match(bsdlParser.COLON)
            self.state = 72
            self.identifier()
            self.state = 73
            self.match(bsdlParser.COLON)
            self.state = 74
            self.match(bsdlParser.EQUAL)
            self.state = 75
            localctx.gv = self.string()
            self.state = 77
            self.match(bsdlParser.CPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.id1 = None # IdentifierContext

        def USE(self):
            return self.getToken(bsdlParser.USE, 0)

        def DOT(self):
            return self.getToken(bsdlParser.DOT, 0)

        def ALL(self):
            return self.getToken(bsdlParser.ALL, 0)

        def identifier(self):
            return self.getTypedRuleContext(bsdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return bsdlParser.RULE_use

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUse" ):
                listener.enterUse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUse" ):
                listener.exitUse(self)




    def use(self):

        localctx = bsdlParser.UseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_use)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.match(bsdlParser.USE)
            self.state = 80
            localctx.id1 = self.identifier()
            self.state = 81
            self.match(bsdlParser.DOT)
            self.state = 82
            self.match(bsdlParser.ALL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AttributeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.atn = None # IdentifierContext
            self.entn = None # IdentifierContext
            self.v = None # General_attribute_assignmentContext

        def ATTRIBUTE(self):
            return self.getToken(bsdlParser.ATTRIBUTE, 0)

        def OF(self):
            return self.getToken(bsdlParser.OF, 0)

        def COLON(self):
            return self.getToken(bsdlParser.COLON, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bsdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(bsdlParser.IdentifierContext,i)


        def general_attribute_assignment(self):
            return self.getTypedRuleContext(bsdlParser.General_attribute_assignmentContext,0)


        def getRuleIndex(self):
            return bsdlParser.RULE_attribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribute" ):
                listener.enterAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribute" ):
                listener.exitAttribute(self)




    def attribute(self):

        localctx = bsdlParser.AttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_attribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self.match(bsdlParser.ATTRIBUTE)
            self.state = 85
            localctx.atn = self.identifier()
            self.state = 86
            self.match(bsdlParser.OF)
            self.state = 87
            localctx.entn = self.identifier()
            self.state = 88
            self.match(bsdlParser.COLON)
            self.state = 89
            localctx.v = self.general_attribute_assignment()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class General_attribute_assignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.v = None # IdentifierContext

        def ENTITY(self):
            return self.getToken(bsdlParser.ENTITY, 0)

        def IS(self):
            return self.getToken(bsdlParser.IS, 0)

        def identifier(self):
            return self.getTypedRuleContext(bsdlParser.IdentifierContext,0)


        def string(self):
            return self.getTypedRuleContext(bsdlParser.StringContext,0)


        def number(self):
            return self.getTypedRuleContext(bsdlParser.NumberContext,0)


        def SIGNAL(self):
            return self.getToken(bsdlParser.SIGNAL, 0)

        def boolean(self):
            return self.getTypedRuleContext(bsdlParser.BooleanContext,0)


        def OPAREN(self):
            return self.getToken(bsdlParser.OPAREN, 0)

        def COMMA(self):
            return self.getToken(bsdlParser.COMMA, 0)

        def BOTH(self):
            return self.getToken(bsdlParser.BOTH, 0)

        def CPAREN(self):
            return self.getToken(bsdlParser.CPAREN, 0)

        def scinot_number(self):
            return self.getTypedRuleContext(bsdlParser.Scinot_numberContext,0)


        def getRuleIndex(self):
            return bsdlParser.RULE_general_attribute_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_attribute_assignment" ):
                listener.enterGeneral_attribute_assignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_attribute_assignment" ):
                listener.exitGeneral_attribute_assignment(self)




    def general_attribute_assignment(self):

        localctx = bsdlParser.General_attribute_assignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_general_attribute_assignment)
        try:
            self.state = 109
            token = self._input.LA(1)
            if token in [bsdlParser.ENTITY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 91
                self.match(bsdlParser.ENTITY)
                self.state = 92
                self.match(bsdlParser.IS)
                self.state = 96
                token = self._input.LA(1)
                if token in [bsdlParser.WORD, bsdlParser.FULLCASE_WORD]:
                    self.state = 93
                    localctx.v = self.identifier()

                elif token in [bsdlParser.STRING]:
                    self.state = 94
                    localctx.v = self.string()

                elif token in [bsdlParser.DIGIT]:
                    self.state = 95
                    localctx.v = self.number()

                else:
                    raise NoViableAltException(self)


            elif token in [bsdlParser.SIGNAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 98
                self.match(bsdlParser.SIGNAL)
                self.state = 99
                self.match(bsdlParser.IS)
                self.state = 107
                token = self._input.LA(1)
                if token in [bsdlParser.TRUE, bsdlParser.FALSE]:
                    self.state = 100
                    localctx.v = self.boolean()

                elif token in [bsdlParser.OPAREN]:
                    self.state = 101
                    self.match(bsdlParser.OPAREN)
                    self.state = 102
                    localctx.v = self.scinot_number()
                    self.state = 103
                    self.match(bsdlParser.COMMA)
                    self.state = 104
                    self.match(bsdlParser.BOTH)
                    self.state = 105
                    self.match(bsdlParser.CPAREN)

                else:
                    raise NoViableAltException(self)


            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BooleanContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(bsdlParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(bsdlParser.FALSE, 0)

        def getRuleIndex(self):
            return bsdlParser.RULE_boolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean" ):
                listener.enterBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean" ):
                listener.exitBoolean(self)




    def boolean(self):

        localctx = bsdlParser.BooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_boolean)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            _la = self._input.LA(1)
            if not(_la==bsdlParser.TRUE or _la==bsdlParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.DIGIT)
            else:
                return self.getToken(bsdlParser.DIGIT, i)

        def getRuleIndex(self):
            return bsdlParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)




    def number(self):

        localctx = bsdlParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 113
                self.match(bsdlParser.DIGIT)
                self.state = 116 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==bsdlParser.DIGIT):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.k = None # IdentifierContext
            self.v = None # StringContext

        def CONSTANT(self):
            return self.getToken(bsdlParser.CONSTANT, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.COLON)
            else:
                return self.getToken(bsdlParser.COLON, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bsdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(bsdlParser.IdentifierContext,i)


        def EQUAL(self):
            return self.getToken(bsdlParser.EQUAL, 0)

        def string(self):
            return self.getTypedRuleContext(bsdlParser.StringContext,0)


        def getRuleIndex(self):
            return bsdlParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)




    def constant(self):

        localctx = bsdlParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 118
            self.match(bsdlParser.CONSTANT)
            self.state = 119
            localctx.k = self.identifier()
            self.state = 120
            self.match(bsdlParser.COLON)
            self.state = 121
            self.identifier()
            self.state = 122
            self.match(bsdlParser.COLON)
            self.state = 123
            self.match(bsdlParser.EQUAL)
            self.state = 124
            localctx.v = self.string()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Port_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.pd = None # Port_defContext

        def PORT(self):
            return self.getToken(bsdlParser.PORT, 0)

        def OPAREN(self):
            return self.getToken(bsdlParser.OPAREN, 0)

        def CPAREN(self):
            return self.getToken(bsdlParser.CPAREN, 0)

        def SCOLON(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.SCOLON)
            else:
                return self.getToken(bsdlParser.SCOLON, i)

        def port_def(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bsdlParser.Port_defContext)
            else:
                return self.getTypedRuleContext(bsdlParser.Port_defContext,i)


        def getRuleIndex(self):
            return bsdlParser.RULE_port_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPort_list" ):
                listener.enterPort_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPort_list" ):
                listener.exitPort_list(self)




    def port_list(self):

        localctx = bsdlParser.Port_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_port_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 126
            self.match(bsdlParser.PORT)
            self.state = 127
            self.match(bsdlParser.OPAREN)
            self.state = 133
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 128
                    localctx.pd = self.port_def()
                    self.state = 129
                    self.match(bsdlParser.SCOLON) 
                self.state = 135
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

            self.state = 136
            localctx.pd = self.port_def()
            self.state = 137
            self.match(bsdlParser.CPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Port_defContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.pname = None # IdentifierContext

        def COLON(self):
            return self.getToken(bsdlParser.COLON, 0)

        def portmode(self):
            return self.getTypedRuleContext(bsdlParser.PortmodeContext,0)


        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bsdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(bsdlParser.IdentifierContext,i)


        def BIT(self):
            return self.getToken(bsdlParser.BIT, 0)

        def BIT_VECTOR(self):
            return self.getToken(bsdlParser.BIT_VECTOR, 0)

        def OPAREN(self):
            return self.getToken(bsdlParser.OPAREN, 0)

        def TO(self):
            return self.getToken(bsdlParser.TO, 0)

        def CPAREN(self):
            return self.getToken(bsdlParser.CPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.COMMA)
            else:
                return self.getToken(bsdlParser.COMMA, i)

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.DIGIT)
            else:
                return self.getToken(bsdlParser.DIGIT, i)

        def getRuleIndex(self):
            return bsdlParser.RULE_port_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPort_def" ):
                listener.enterPort_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPort_def" ):
                listener.exitPort_def(self)




    def port_def(self):

        localctx = bsdlParser.Port_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_port_def)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 139
                    localctx.pname = self.identifier()
                    self.state = 140
                    self.match(bsdlParser.COMMA) 
                self.state = 146
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

            self.state = 147
            localctx.pname = self.identifier()
            self.state = 148
            self.match(bsdlParser.COLON)
            self.state = 149
            self.portmode()
            self.state = 165
            token = self._input.LA(1)
            if token in [bsdlParser.BIT]:
                self.state = 150
                self.match(bsdlParser.BIT)

            elif token in [bsdlParser.BIT_VECTOR]:
                self.state = 151
                self.match(bsdlParser.BIT_VECTOR)
                self.state = 152
                self.match(bsdlParser.OPAREN)
                self.state = 154 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 153
                    self.match(bsdlParser.DIGIT)
                    self.state = 156 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==bsdlParser.DIGIT):
                        break

                self.state = 158
                self.match(bsdlParser.TO)
                self.state = 160 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 159
                    self.match(bsdlParser.DIGIT)
                    self.state = 162 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==bsdlParser.DIGIT):
                        break

                self.state = 164
                self.match(bsdlParser.CPAREN)

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FULLCASE_WORD(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.FULLCASE_WORD)
            else:
                return self.getToken(bsdlParser.FULLCASE_WORD, i)

        def WORD(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.WORD)
            else:
                return self.getToken(bsdlParser.WORD, i)

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.DIGIT)
            else:
                return self.getToken(bsdlParser.DIGIT, i)

        def getRuleIndex(self):
            return bsdlParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = bsdlParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            _la = self._input.LA(1)
            if not(_la==bsdlParser.WORD or _la==bsdlParser.FULLCASE_WORD):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
            self.state = 171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 117)) & ~0x3f) == 0 and ((1 << (_la - 117)) & ((1 << (bsdlParser.WORD - 117)) | (1 << (bsdlParser.FULLCASE_WORD - 117)) | (1 << (bsdlParser.DIGIT - 117)))) != 0):
                self.state = 168
                _la = self._input.LA(1)
                if not(((((_la - 117)) & ~0x3f) == 0 and ((1 << (_la - 117)) & ((1 << (bsdlParser.WORD - 117)) | (1 << (bsdlParser.FULLCASE_WORD - 117)) | (1 << (bsdlParser.DIGIT - 117)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self.consume()
                self.state = 173
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 182
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bsdlParser.USCORE:
                self.state = 174
                self.match(bsdlParser.USCORE)
                self.state = 176 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 175
                    _la = self._input.LA(1)
                    if not(((((_la - 117)) & ~0x3f) == 0 and ((1 << (_la - 117)) & ((1 << (bsdlParser.WORD - 117)) | (1 << (bsdlParser.FULLCASE_WORD - 117)) | (1 << (bsdlParser.DIGIT - 117)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self.consume()
                    self.state = 178 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 117)) & ~0x3f) == 0 and ((1 << (_la - 117)) & ((1 << (bsdlParser.WORD - 117)) | (1 << (bsdlParser.FULLCASE_WORD - 117)) | (1 << (bsdlParser.DIGIT - 117)))) != 0)):
                        break

                self.state = 184
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PortmodeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(bsdlParser.IN, 0)

        def OUT(self):
            return self.getToken(bsdlParser.OUT, 0)

        def INOUT(self):
            return self.getToken(bsdlParser.INOUT, 0)

        def BUFFER(self):
            return self.getToken(bsdlParser.BUFFER, 0)

        def LINKAGE(self):
            return self.getToken(bsdlParser.LINKAGE, 0)

        def BUS(self):
            return self.getToken(bsdlParser.BUS, 0)

        def getRuleIndex(self):
            return bsdlParser.RULE_portmode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPortmode" ):
                listener.enterPortmode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPortmode" ):
                listener.exitPortmode(self)




    def portmode(self):

        localctx = bsdlParser.PortmodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_portmode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            _la = self._input.LA(1)
            if not(((((_la - 30)) & ~0x3f) == 0 and ((1 << (_la - 30)) & ((1 << (bsdlParser.BUFFER - 30)) | (1 << (bsdlParser.BUS - 30)) | (1 << (bsdlParser.IN - 30)) | (1 << (bsdlParser.INOUT - 30)) | (1 << (bsdlParser.LINKAGE - 30)) | (1 << (bsdlParser.OUT - 30)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StringContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.STRING)
            else:
                return self.getToken(bsdlParser.STRING, i)

        def ANDSIGN(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.ANDSIGN)
            else:
                return self.getToken(bsdlParser.ANDSIGN, i)

        def getRuleIndex(self):
            return bsdlParser.RULE_string

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString" ):
                listener.enterString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString" ):
                listener.exitString(self)




    def string(self):

        localctx = bsdlParser.StringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_string)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 187
                    self.match(bsdlParser.STRING)
                    self.state = 188
                    self.match(bsdlParser.ANDSIGN) 
                self.state = 193
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

            self.state = 194
            self.match(bsdlParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Scinot_numberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(bsdlParser.DOT, 0)

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(bsdlParser.DIGIT)
            else:
                return self.getToken(bsdlParser.DIGIT, i)

        def getRuleIndex(self):
            return bsdlParser.RULE_scinot_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScinot_number" ):
                listener.enterScinot_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScinot_number" ):
                listener.exitScinot_number(self)




    def scinot_number(self):

        localctx = bsdlParser.Scinot_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_scinot_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bsdlParser.DIGIT:
                self.state = 196
                self.match(bsdlParser.DIGIT)
                self.state = 201
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 202
            self.match(bsdlParser.DOT)
            self.state = 206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bsdlParser.DIGIT:
                self.state = 203
                self.match(bsdlParser.DIGIT)
                self.state = 208
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 209
            self.match(bsdlParser.T__0)
            self.state = 211
            _la = self._input.LA(1)
            if _la==bsdlParser.T__1:
                self.state = 210
                self.match(bsdlParser.T__1)


            self.state = 216
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bsdlParser.DIGIT:
                self.state = 213
                self.match(bsdlParser.DIGIT)
                self.state = 218
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx






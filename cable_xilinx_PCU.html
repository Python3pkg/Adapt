<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Adapt : Linux USB JTAG controller for Digilent boards." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Adapt</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/diamondman/Adapt">View on GitHub</a>

          <h1 id="project_title">Adapt</h1>
          <h2 id="project_tagline">Linux USB JTAG controller for Digilent boards.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/diamondman/Adapt/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/diamondman/Adapt/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3><a name="flashing-concerns" class="anchor" href="#flashing-concerns"><span class="octicon octicon-link"></span></a>Xilinx Platform Cable USB (XPCU) Documentation.</h3>


<table>
  <tbody>
    <tr>
      <td><strong>Microprocessor</strong></td>
      <td>Cypress EZ-USB FX2LP</td>
    </tr>
    <tr>
      <td><strong>Hardware Accelerated</strong></td>
      <td>Yes (Xilinx XC2C256)</td>
    </tr>
    <tr>
      <td><strong>Firmware Stored in Flash</strong></td>
      <td>No. Reloaded every power on.</td>
    </tr>
    <tr>
      <td><strong>Firmware State</strong></td>
      <td>Proprietary. Mostly reversed.</td>
    </tr>
    <tr>
      <td><strong>Firmware Path</strong></td>
      <td>{Latest ISE path}/ISE_DS/ISE/bin/lin/xusb_emb.hex</td>
    </tr>
    <tr>
      <td><strong>Latest Firmware Version</strong></td>
      <td>1028 (0x0404)</td>
    </tr>
  </tbody>
</table>


<ol>
  <li><a href="#getting-started">Getting Started</a></li>
  <li><a href="#proto-specs">Protocol Specifications</a></li>
  <li><a href="#dv-specs">Device Specifications</a></li>
  <li><a href="#troubleshooting">TroubleShooting</a></li>
</ol>


<h3><a name="getting-started" class="anchor" href="#getting-started"><span class="octicon octicon-link"></span></a>Getting Started</h3>
	<p>The XPCU controller powers on with no firmware. Loading firmware will cause the device to re-enumerate as a different usb device. Checking lsusb for the idvendor and idproduct will show if the device is programmed.</p>
<table>
  <thead>
    <tr><td></td><td><strong>Default</strong></td><td><strong>Programmed<strong></td></tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>idVendor</strong></td><td>0x03FD</td><td>0x03FD</td>
    </tr>
    <tr>
      <td><strong>idProduct</strong></td><td>0x000D</td><td>0x0008</td>
    </tr>
  </tbody>
</table>
<p>Some cables may have different default values. Please report any you find.</p>

<p>Loading the XPCU with firmware can be done with the fxload tool. It can be used manually through the terminal, but the following udev rule will auto load the firmware every time the XPCU is plugged into the host machine.</p>
<h5>UDEV Rule for auto firmware loading</h5>
<p>Write the following lines to /etc/udev/rules.d/xusbfwu.rules and set the file permission to 644.</p>
<pre>SUBSYSTEM=="usb", ACTION=="add", ATTR{idVendor}=="03fd", ATTR{idProduct}=="000d", MODE="666", RUN+="/sbin/fxload -v -t fx2 -I '/path/to/xusb_emb.hex' -D $tempnode"
SUBSYSTEM=="usb", ACTION=="add", ATTR{idVendor}=="03fd", ATTR{idProduct}=="0008", MODE="666"</pre>
<p>When the device is next plugged into USB after a short delay, the led should turn green or red (depending if a JTAG target is detected). If no light turns on, the firmware is not being loaded right. If the light turns on but the device behaves oddly, see the troubleshooting section.</p>

<h3><a name="proto-specs" class="anchor" href="#proto-specs"><span class="octicon octicon-link"></span></a>Protocol Specification</h3>

<p>The USB specification requires the host to initiate all transfers. Control messages to endpoint 0 control the XPCU. Bulk transfers send jtag data for the command to use (if any).</p>

For all jtag related USB-control messages.
<table>
  <tr>
    <td><strong>bRequest</strong></td>
    <td>0xB0</td>
  </tr>
  <tr>
    <td><strong>bmRequestType<strong></td>
    <td>
      OUT(To XPCU): 0x40<br>
      IN(To PC): 0xC0
    </td>
  </tr>
  <tr>
    <td><strong>wValue</strong></td>
    <td>Command number (lower byte)</td>
  </tr>
  <tr>
    <td><strong>wIndex</strong></td>
    <td>Parameter to Command</td>
  </tr>
  <tr>
    <td><strong>wLength</strong></td>
    <td>Number of bytes to send in control message.</td>
  </tr>
  <tr>
    <td><strong>Bulk OUT Endpoint</strong></td>
    <td>EP2</td>
  </tr>
  <tr>
    <td><strong>Bulk IN Endpoint</strong></td>
    <td>EP6</td>
  </tr>
</table>




<table>
  <thead><tr>
      <th>Name</th>
      <th>Dir</th>
      <th>Value</th>
      <th>Index</th>
      <th>LEN</th>
      <th>Description</th>
  </tr></thead>
  <tbody>
    <tr>
      <td>Device Enable</td>
      <td>O</td>
      <td>0x18</td>
      <td>0</td>
      <td>0</td>
      <td>Required before the device will behave normally. Before running this command, you seem to still be able to read GPIO states, but and transfer commands will do nothing.</td>
    </tr>
    <tr>
      <td>Device Disable</td>
      <td>O</td>
      <td>0x10</td>
      <td>0</td>
      <td>0</td>
      <td>Not required, but you should clean up.</td>
    </tr>
    <tr>
      <td>Set JTAG Speed</td>
      <td>O</td>
      <td>0x28</td>
      <td>Speed</td>
      <td>0</td>
      <td>Specifies a speed class for the target device and changes the speed of all furure JTAG transfers. Often 0x11. Bit 4 should always be set in the speed class.</td>
    </tr>
    <tr>
      <td>Read GPIO</td>
      <td>I</td>
      <td>0x38</td>
      <td>0</td>
      <td>1</td>
      <td>Has some side effects. Not sure completely what they are, but when run after enabling the device, it will cause the GPIO lines to change to a default value of some kind. It will then report that TDO and TMS are high. Calling it again will show that only TDO is high, as will further calls. This instruction is not well understood and the name largely comes from other reverse engineering efforts.</td>
    <tr>
      <td rowspan="3">Bulk JTAG Transfer</td>
      <td>O</td>
      <td>0xa6</td>
      <td>Number of bits to transfer minus 1 (0->1)</td>
      <td>0</td>
      <td>Starts a transfer</td>
    </tr>
    <tr>
      <td colspan="5"><em>Bulk: OUT Endpoint: 2</em><br>
	The data to put on the GPIO lines. The data consists of sets of two bytes where each four bits are a field. Each bit of the fields line up so each two byte message communicates 4 actions.<br>
	<strong>0xABCD</strong><br>
	<ul>
	  <li>A: TMS field</li>
	  <li>B: TDI flag</li>
	  <li>C: Read TDO field</li>
	  <li>D: Clock field</li>
	</ul>
	<p>TMS and TDI bits are relatively self explanatory and simply specify if those lines should be held low or high for the operation.</p>
	<p>The TDO field is used to tell the Platform Cable that the tdo line should be sampled during this operation.</p>
	<p>The Clock field is unique in that a 1 in a bit position signifies a full clock cycle and not just setting the state to low or high. If the clock field is 0b1111 There will be 4 full clock cycles (CLK: low->high then high->low). Consequently a 0 in the Clock field translates to no action on the CLK line for the operation. This approach effectively doubles the transfer rate since bits do not need to be wasted on lowering the clock, and we can send/receive up to 4 bits on TDI/TDO with TMS changes for every two bytes sent.</p>

	<p>The four operations specified by a two byte message are run from least significant bit to most significant bit. Sending more than one two byte message will cause the left most one (First part sent over the wire) to be executed first.</p>
	<h3>Example 1:</h3>
	<p>This example will move the <a href="https://en.wikipedia.org/wiki/Joint_Test_Action_Group#Communications_model">TAP</a> state through TEST_LOGIC_RESET and end in RUN_TEST_IDLE. Red is TMS. Yellow is TCK.</p>
	<code>Bits: 10</code><br>
	<code>Data: 0x80:00:f0:0f:10:03</code><br>
	<code>xpcu_GPIO_transfer(dh, 9, '\x80\x00\xf0\x0f\x10\x03')</code><br>
	<h5>Disection (reading each column of the numbers lined up):</h5>
	<code>0x8000</code><br><code>0xf00f</code><br><code>0x1003</code><br>
	<strong>TMS:</strong> 0x8, 0xf, 0x1 Bin = <strong>1000 1111 0001</strong><br>
	<strong>TDI:</strong> 0x0, 0x0, 0x0 (All 0 means TDI is always low. Ignoring for example.)<br>
	<strong>TDO:</strong> 0x0, 0x0, 0x0 (All 0 means read no bits. Ignoring for example.)<br>
	<strong>TXK:</strong> 0x0, 0xf, 0x3 Bin = <strong>0000 1111 0011</strong><br>
	<h5>Reverse each 4 bit section bin(hijk)->bin(kjih):</h5>
	<strong>TMS:</strong> 1000 1111 0001 -> <strong>0001 1111 1000</strong><br>
	<strong>TXK:</strong> 0000 1111 0011 -> <strong>0000 1111 1100</strong>
	<img src="images/xpcu/80_00_f0_0f_10_03_(9).png">

	<h3>Example 2:</h3>
	<code>Bits: 10</code><br>
	<code>Data: 0x00:00:f0:0f:10:03</code><br>
	<code>xpcu_GPIO_transfer(dh, 9, '\x00\x00\x00\x0f\x10\x03')</code><br>
	<img src="images/xpcu/d0_00_f0_0f_10_03_(9).png">

	<h3>Example 3:</h3>
	<code>Bits: 10</code><br>
	<code>Data: 0x00:00:f0:0f:10:03</code><br>
	<code>xpcu_GPIO_transfer(dh, 9, '\x00\x00\x00\x0f\x10\x03')</code><br>
	<img src="images/xpcu/00_00_00_0f_10_03_(9).png">

	<h3>Example 4:</h3>
	<code>Bits: 13</code><br>
	<code>Data: 0x00:00:f0:0f:10:03</code><br>
	<code>xpcu_GPIO_transfer(dh, 12, '\x80\x00\xf0\x0f\x10\x0b\x00\x01')</code><br>
	<strong>Note:</strong> For two byte sections where all four state transitions are used, the Platform cable groups those bits and pushes any fractional section off a little while later (likely because of processing delay).
	<img src="images/xpcu/0x80_00_f0_0f_10_0b_00_01_(12).png">

      </td>
    </tr>
    <tr>
      <td colspan="5"><em>Bulk: IN Endpoint: 6</em><br>
	This response message is returned from the Platform Cable after the transfer is completed if any read TDO bits were high in the request message. If no read TDO bits were high, this message is not returned.
	<p>The returned data comes back in groups of two bytes. This means you will get a minimum of two bytes of response data if this message is returned.</p>
      </td>
    </tr>
    
    </tr>
    
  </tbody>
</table>


<h3><a name="troubleshooting" class="anchor" href="#troubleshooting"><span class="octicon octicon-link"></span></a>Troubleshooting</h3>    
<p><strong>If you want to check the version of firmware you have?</strong></p>
<pre>
  FW_VERSION_STRING=`grep ":0219B900" <strong>$PATH_TO_FIRMWARE_FILE`</strong>;
  FW_HEX_VERSION=${FW_VERSION_STRING:9:4};
  printf "%d" 0x$FW_HEX_VERSION;
</pre>

<p><strong>Green light solid after firmware load but device acting weird?</strong></p>
<p>The firmware hex file for this device can be found inside the linux install of ISE. There are several files with the same name at various locations, but ignore them and use the one at {Latest ISE path}/ISE_DS/ISE/bin/lin/xusb_emb.hex. If you use the wrong file, it will either refuse to load, or appear to load but not re-enumerate properly and behave oddly despite the green light on the device lighting up.</p>


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Adapt maintained by <a href="https://github.com/diamondman">diamondman</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>

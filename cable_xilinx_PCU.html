<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Adapt : Linux USB JTAG controller for Digilent boards." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Adapt</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/diamondman/Adapt">View on GitHub</a>

          <h1 id="project_title">Adapt</h1>
          <h2 id="project_tagline">Linux USB JTAG controller for Digilent boards.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/diamondman/Adapt/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/diamondman/Adapt/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3><a name="flashing-concerns" class="anchor" href="#flashing-concerns"><span class="octicon octicon-link"></span></a>Xilinx Platform Cable USB (XPCU) Documentation.</h3>


<table>
  <tbody>
    <tr>
      <td><strong>Microprocessor</strong></td>
      <td>Cypress EZ-USB FX2LP</td>
    </tr>
    <tr>
      <td><strong>Hardware Accelerated</strong></td>
      <td>Yes (Xilinx XC2C256)</td>
    </tr>
    <tr>
      <td><strong>Firmware Stored in Flash</strong></td>
      <td>No. Reloaded every power on.</td>
    </tr>
    <tr>
      <td><strong>Firmware State</strong></td>
      <td>Proprietary. Mostly reversed.</td>
    </tr>
    <tr>
      <td><strong>Firmware Path</strong></td>
      <td>
	{Latest ISE path}/ISE_DS/ISE/bin/lin/xusb_emb.hex<br>
	{Latest ISE path}/ISE_DS/ISE/bin/lin/xusb_xlp.hex
      </td>
    </tr>
    <tr>
      <td><strong>Latest Firmware Version</strong></td>
      <td>
	EMB: 1028 (0x0404).<br>
	XLP: 5381 (0x1705)
      </td>
    </tr>
  </tbody>
</table>


<ol>
  <li><a href="#getting-started">Getting Started</a></li>
  <li><a href="#interface-selection">Interface Selection</a></li>
  <li><a href="#proto-specs">Protocol Specifications</a></li>
  <li><a href="#dv-specs">Device Specifications</a></li>
  <li><a href="#troubleshooting">Trouble Shooting</a></li>
</ol>


<h3><a name="getting-started" class="anchor" href="#getting-started"><span class="octicon octicon-link"></span></a>Getting Started</h3>
	<p>The XPCU controller powers on with no firmware. Loading firmware will cause the device to re-enumerate as a different usb device. Checking lsusb for the idvendor and idproduct will show if the device is programmed.</p>
<table>
  <thead>
    <tr><td></td><td><strong>Default</strong></td><td><strong>Programmed<strong></td></tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>idVendor</strong></td><td>0x03FD</td><td>0x03FD</td>
    </tr>
    <tr>
      <td><strong>idProduct</strong></td><td>0x000D</td><td>0x0008</td>
    </tr>
  </tbody>
</table>
<p>Some cables may have different default values. Please report any you find.</p>

<p>Loading the XPCU with firmware can be done with the fxload tool. It can be used manually through the terminal, but the following udev rule will auto load the firmware every time the XPCU is plugged into the host machine.</p>


<h3><a name="interface-selection" class="anchor" href="#interface-selection"><span class="octicon octicon-link"></span></a>Interface Selection</h3>
	<p>The newer XLP firmware for the Platform Cable 1 requires USB interface claiming, and Interface alternate mode selection to work. Using libusb1.0, run libusb_claim_interface(0), then libusb_set_interface_alt_setting(0, 1). Trying to send bulk commands before these steps are done will fail. Devices requiring this step can be identified with the productID of 0x0D.</p>



<h3>UDEV Rule for auto firmware loading</h5>
<p>Write the following lines to /etc/udev/rules.d/xusbfwu.rules and set the file permission to 644.</p>
<pre>SUBSYSTEM=="usb", ACTION=="add", ATTR{idVendor}=="03fd", ATTR{idProduct}=="000d", MODE="666", RUN+="/sbin/fxload -v -t fx2 -I '/path/to/xusb_emb.hex' -D $tempnode"
SUBSYSTEM=="usb", ACTION=="add", ATTR{idVendor}=="03fd", ATTR{idProduct}=="0008", MODE="666"</pre>
<p>When the device is next plugged into USB after a short delay, the led should turn green or red (depending if a JTAG target is detected). If no light turns on, the firmware is not being loaded right. If the light turns on but the device behaves oddly, see the troubleshooting section.</p>

<h3><a name="proto-specs" class="anchor" href="#proto-specs"><span class="octicon octicon-link"></span></a>Protocol Specification</h3>

<p>The USB specification requires the host to initiate all transfers. Control messages to endpoint 0 control the XPCU. Bulk transfers send jtag data for the command to use (if any).</p>

For all jtag related USB-control messages.
<table>
  <tr>
    <td><strong>bRequest</strong></td>
    <td>0xB0</td>
  </tr>
  <tr>
    <td><strong>bmRequestType<strong></td>
    <td>
      OUT(To XPCU): 0x40<br>
      IN(To PC): 0xC0
    </td>
  </tr>
  <tr>
    <td><strong>wValue</strong></td>
    <td>Command number (lower byte)</td>
  </tr>
  <tr>
    <td><strong>wIndex</strong></td>
    <td>Parameter to Command</td>
  </tr>
  <tr>
    <td><strong>wLength</strong></td>
    <td>Number of bytes to send in control message.</td>
  </tr>
  <tr>
    <td><strong>Bulk OUT Endpoint</strong></td>
    <td>EP2</td>
  </tr>
  <tr>
    <td><strong>Bulk IN Endpoint</strong></td>
    <td>EP6</td>
  </tr>
</table>




<table>
  <thead><tr>
      <th>Name</th>
      <th>Dir</th>
      <th>Value</th>
      <th>Index</th>
      <th>LEN</th>
      <th>Description</th>
  </tr></thead>
  <tbody>
    <tr>
      <td>Device Disable</td>
      <td>O</td>
      <td>0x10</td>
      <td>0</td>
      <td>0</td>
      <td>Not required, but you should clean up.</td>
    </tr>
    <tr>
      <td>Device Enable</td>
      <td>O</td>
      <td>0x18</td>
      <td>0</td>
      <td>0</td>
      <td>Required before the device will behave normally. Before running this command, you seem to still be able to read GPIO states, but and transfer commands will do nothing.</td>
    </tr>
    <tr>
      <td>Reverse windex</td>
      <td>I</td>
      <td>0x20</td>
      <td>low byte to reverse</td>
      <td>1</td>
      <td>Returns the lower 8 bits of the windex value passed into it</td>
    </tr>
    <tr>
      <td>Set JTAG Speed</td>
      <td>O</td>
      <td>0x28</td>
      <td>Speed</td>
      <td>0</td>
      <td>
	Specifies a speed class for the target device and changes the speed of all future JTAG transfers. Often 0x11. Bit 4 should always be set in the speed class.<br>
	Below is a table of values to send to the controller, and what speed that translates to.
	<table>
	  <thead>
	    <td>Value</td>
	    <td>Bitrate</td>
	  </thead>
	  <tr>
	    <td>0</td>
	    <td>12 MegaHertz</td>
	  </tr>
	  <tr>
	    <td>1</td>
	    <td>6 MegaHertz</td>
	  </tr>
	  <tr>
	    <td>2</td>
	    <td>3 MegaHertz</td>
	  </tr>
	  <tr>
	    <td>3</td>
	    <td>1.5 MegaHertz</td>
	  </tr>
	  <tr>
	    <td>4</td>
	    <td>750 KiloHertz</td>
	  </tr>
	</table>
      </td>
    </tr>
    <tr>
      <td>Write Single JTAG bit</td>
      <td>O</td>
      <td>0x30</td>
      <td>pinstates</td>
      <td>0</td>
      <td>
	This command will perform writes on either the JTAG target or the internal CPLD. Which one it targets is controlled by command 0x52.
	<h6>DEFAULT (CPLD UPGRADE MODE OFF)</h6>
	<p>
	  Perform a single GPIF write to the CPLD. Format is not known for now. Full clock cycle appears appears to happen. Only the lower byte of windex is used.
	</p>
	<h6>WHEN CPLD UPGRADE MODE ON</h6>
	<p>
	  Bit bang the internal CPLD's JTAG TDI/TMS/TCK lines. Only up to one transition on each line can be done per request. This means that in order to make one clock cycle for the CPLD's TAP, this message must be sent twice: once to raise TCK and another to lower it again. This makes JTAG operations on the embedded CPLD very <em>very</em> slow. Thus it is only used for upgrading the firmware on the CPLD.
	  <table>
	    <thead>
	      <tr><td><strong>Bit</strong></td><td><strong>Meaning</strong></td></tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>windex.0</td>
		<td>CPLD TDI</td>
	      </tr>
	      <tr>
		<td>windex.1</td>
		<td>CPLD TMS</td>
	      </tr>
	      <tr>
		<td>windex.2</td>
		<td>CPLD TCK</td>
	      </tr>
	    </tbody>
	  </table>
	</p>
      </td>
    </tr>
    <tr>
      <td>Read Single JTAG bit and Status</td>
      <td>I</td>
      <td>0x38</td>
      <td>0</td>
      <td>1</td>
      <td>
	This command will operate on the JTAG target or the internal CPLD's TAP. Which one it targets is controlled by command 0x52.
	<h6>DEFAULT (CPLD UPGRADE MODE OFF)</h6>
	<p>
	  <table>
	    <thead>
	      <tr><td><strong>Bit</strong></td><td><strong>Meaning</strong></td></tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>0</td>
		<td>Always seems to be 1 (not verified).</td>
	      </tr>
	      <tr>
		<td>1</td>
		<td>
		  The TDO bit of the JTAG target. Exceptions are as follow:
		  <ul>
		    <li>Always 1 if JTAG is disabled. Effect is immediate.</li>
		    <li>If checked immediately after enabling JTAG, returns 1. Check it again right after that and it will be 0 consistently.</li>
		    <li>If the XPCU's JTAG VCC pin is not attached to a valid source, this bit will always be 0 (net verified on the 'always' part).</li>
		  </ul>
		</td>
	      </tr>
	      <tr>
		<td>6</td>
		<td>On if the XPCU is attached to a JTAG target (JTAG VCC high).</td>
	      </tr>
	    </tbody>
	  </table>
	</p>
	<h6>WHEN CPLD UPGRADE MODE ON</h6>
	<p>
	  Read the state of the TDO pin of the internal CPLD. Will return 0 or 1. No clocking is done, the read is passive.
	</p>
    </tr>
    <tr>
      <td>Return Constant</td>
      <td>I</td>
      <td>0x40</td>
      <td>0</td>
      <td>2</td>
      <td>Returns 0xB503</td>
    </tr>
    <tr>
      <td>Maybe Read Serial Number?</td>
      <td>I</td>
      <td>0x42</td>
      <td>0</td>
      <td>0</td>
      <td>Available on the XLP firmware. Returns 8 bytes of data. On XPC1, all data is 0. May be a serial number for devices that support it.</td>
    </tr>
    <tr>
      <td>Get Version</td>
      <td>I</td>
      <td>0x50</td>
      <td>0,1,2,3+</td>
      <td>2</td>
      <td>
	Returns information on version numbers of the software running on the device.
	<table>
	  <thead>
	    <tr><td><strong>wvalue</strong></td><td><strong>Firmware to check</strong></td></tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td>0</td>
	      <td>FX2 firmware(the hex file).</td>
	    </tr>
	    <tr>
	      <td>1</td>
	      <td>CPLD Accelerator</td>
	    </tr>
	    <tr>
	      <td>2</td>
	      <td>returns 0x0400</td>
	    </tr>
	    <tr>
	      <td>3+</td>
	      <td>returns 0x0506</td>
	    </tr>
	  </tbody>
	</table>
      </td>
    </tr>
    <tr>
      <td>CPLD Upgrade Mode</td>
      <td>O</td>
      <td>0x52</td>
      <td><strong>0:</strong> Off<br><strong>1:</strong> On</td>
      <td>0</td>
      <td>
	Enabling CPLD UPGRADE MODE is only used for upgrading the internal CPLD. The XPCU controller starts with this mode disabled.
	<h6>CPLD UPGRADE MODE ON</h6>
	<p>
	  <ul>
	    <li>Normal JTAG operations disables</li>
	    <li>LED set to RED</li>
	    <li>Commands 0x30 and 0x38 now operate write/read onh the internal CPLD as a target</li>
	  </ul>
	</p>
	<h6>CPLD UPGRADE MODE OFF</h6>
	<p>
	  <ul>
	    <li>Normal JTAG operations restored</li>
	    <li>LED restored to normal operation</li>
	    <li>Single JTAG read/write commands operate on the JTAG port.</li>
	  </ul>
	</p>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN</td>
      <td>O</td>
      <td>0x68</td>
      <td>Some count</td>
      <td>0</td>
      <td>The lower byte of windex is set to the address lines to the CPLD. <br>The upper byte is written to XGPIFSGLDATLX which triggers a GPIF transaction.</td>
    </tr>
    <tr>
      <td>Generate Heat and clock CPLD</td>
      <td>I</td>
      <td>0x7<strong>X</strong></td>
      <td>seems pointless</td>
      <td>0/1</td>
      <td>
	This command is very odd. The waveform for talking to the CPLD does nothing except loop waiting for the CPLD to say it is done. windex is set as the data to write to the CPLD but the waveform never asserts data.<br>
	windex is incremented by one. Processed min is therefore 1. 0xFFFE becomes 0xFFFF, but there is a maximum enforced that keeps 0xFFFF at 0xFFFF (instead of 0x01000000).
	Commands runs a single GPIF waveworm if the Value is 0x70 to 0x7F (inclusive).<br>
	CPLD EXTEND pin raised.<br>
	The value of X determines a few things:
	<ul>
	  <li>CPLD's TMS_LEVEL pin:
	    <ul>
	      <li> Lowered for 0, 1, 4, 5, 8, 9, C, D</li>
	      <li> Raised for 2, 3, 6, 7, A, B, E, F</li>
	    </ul>
	  </li>
	  <li>Returns 1 byte (the wvalue low byte) if X is odd. Otherwise return nothing.</li>
	  <li>JPT pins to CPLD are set prior to GPIF transaction:
	    <ul>
	      <li> JPT=0b000 if X in range 0x08 to 0x0F</li>
	      <li> JPT=0b110 if X in range 0x00 to 0x07</li>
	    </ul>
	  </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN</td>
      <td>??</td>
      <td>6C 88 8A 8c 8E 90 92 94 96 98 9A 9C 9E A2 A4</td>
      <td>UNKNOWN</td>
      <td>???</td>
      <td>Part of a very large block of code with unknown function. No packet captures use these commands. Originally thought to be used for SPI or serial. Unknown function at this time. Appears some of these commands can trigger the same function that 0x7X messages call</td>
    </tr>
    <tr>
      <td>Change USB Speed(?)</td>
      <td>O</td>
      <td>0xA0</td>
      <td>0</td>
      <td>0</td>
      <td>Mostly resets the XPCU, disconnects it from USB, forces full speed USB, then reconnects the XPCU to USB.</td>
    </tr>
    <tr>
      <td rowspan="3">Bulk JTAG Transfer</td>
      <td>O</td>
      <td>0xa6</td>
      <td>0xYYZZ See description</td>
      <td>0</td>
      <td>Starts a transfer.
	<ul>
	  <li>24 bit number. 0xXXYYZZ where XX is upper byte of wvalue.</li>
	  <li>0 indexed. 0 means 1, 1 means 2, etc.</li>
	  <li>JTAG information is provided in following bulk transfers.</li>
	</ul>
      </td>
    </tr>
    <tr>
      <td colspan="5"><em>Bulk: OUT Endpoint: 2</em><br>
	The data to put on the GPIO lines. The data consists of pairs of bytes (two bytes) where each four bit section is a field. Each bit of the fields line up to form key frames. Up to four (4) key frames can be specified per 2 bytes sent. Details on the order the keyframes are executed is below.<br>
	<p><strong>Two Byte Format: 0xABCD</strong></p>

	<table>
	  <thead>
	    <th>KEY</th>
	    <th>NAME</th>
	    <th>DESCRIPTION</th>
	  </thead>
	  <tbody>
	    <tr>
	      <td>A</td>
	      <td>TMS</td>
	      <td>Bits to put on the TMS line for each keyframe.</td>
	    </tr>
	    <tr>
	      <td>B</td>
	      <td>TDI</td>
	      <td>Bits to put on the TDI line for each keyframe.</td>
	    </tr>
	    <tr>
	      <td>C</td>
	      <td>TDO</td>
	      <td>Whether of not to read the TDO line for each keyframe.</td>
	    </tr>
	    <tr>
	      <td>D</td>
	      <td>TCK</td>
	      <td>Whether to do a full clock cycle on the TCK line for each keyframe.</td>
	    </tr>
	  </tbody>
	</table>
	<p>Please note the following:</p>
	<ul>
	  <li>TCK specifying full cycles instead of just setting the TCK line high or low effectively doubles the transfer rate of the controller.</li>
	  <li>All data must come in pairs of bytes (multiples of 2 bytes).</li>
	  <li>Keyframes are executed least significant bit to most significant bit, starting with the first byte of the array.</li>
	  <li>If a number of transitions is specified in the control message that is not divisible by 4, keyframes from the last two byte group of the bulk message will be clipped starting from the most significant bit.</li>
	</ul>

	<h3>Example 1:</h3>
	<p>This example will move the <a href="https://en.wikipedia.org/wiki/Joint_Test_Action_Group#Communications_model">TAP</a> state through TEST_LOGIC_RESET and end in RUN_TEST_IDLE. Red is TMS. Yellow is TCK.</p>
	<p><strong>Note:</strong> For two byte sections where all four state transitions are used, the Platform cable groups those bits and pushes any fractional section off a little while later (likely because of processing delay).</p>
	<code>Bits: 10</code><br>
	<code>Data: 0x80:00:F0:0F:10:03</code><br>
	<code>xpcu_GPIO_transfer(dh, 9, '\x80\x00\xF0\x0F\x10\x03')</code><br>
	<h5>Disection (reading each column of the numbers lined up):</h5>
	<code>0x8000</code><br><code>0xf00f</code><br><code>0x1003</code><br>
	<strong>TMS:</strong> 0x8, 0xf, 0x1 Bin = <strong>1000 1111 0001</strong><br>
	<strong>TDI:</strong> 0x0, 0x0, 0x0 (All 0 means TDI is always low. Ignoring for example.)<br>
	<strong>TDO:</strong> 0x0, 0x0, 0x0 (All 0 means read no bits. Ignoring for example.)<br>
	<strong>TXK:</strong> 0x0, 0xf, 0x3 Bin = <strong>0000 1111 0011</strong><br>
	<h5>Reverse each 4 bit section bin(hijk)->bin(kjih):</h5>
	<strong>TMS:</strong> 1000 1111 0001 -> <strong>0001 1111 1000</strong><br>
	<strong>TXK:</strong> 0000 1111 0011 -> <strong>0000 1111 1100</strong>
	<img src="images/xpcu/80_00_f0_0f_10_03_(9).png">

	<h3>Example 2:</h3>
	<code>Bits: 10</code><br>
	<code>Data: 0xD0:00:F0:0F:10:03</code><br>
	<code>xpcu_GPIO_transfer(dh, 9, '\xD0\x00\xF0\x0F\x10\x03')</code><br>
	<img src="images/xpcu/d0_00_f0_0f_10_03_(9).png">

	<h3>Example 3:</h3>
	<code>Bits: 10</code><br>
	<code>Data: 0x00:00:F0:0F:10:03</code><br>
	<code>xpcu_GPIO_transfer(dh, 9, '\x00\x00\x00\x0F\x10\x03')</code><br>
	<img src="images/xpcu/00_00_00_0f_10_03_(9).png">

	<h3>Example 4:</h3>
	<code>Bits: 13</code><br>
	<code>Data: 0x80:00:F0:0F:10:0B:00:01</code><br>
	<code>xpcu_GPIO_transfer(dh, 12, '\x80\x00\xF0\x0F\x10\x0B\x00\x01')</code><br>
	<img src="images/xpcu/0x80_00_f0_0f_10_0b_00_01_(12).png">

      </td>
    </tr>
    <tr>
      <td colspan="5"><em>Bulk: IN Endpoint: 6</em><br>
	This response message is returned from the Platform Cable after the transfer is completed if any read TDO bits were high in the request message. If no read TDO bits were high, this message is not returned.
	<p>The return protocol is rather complicated.</p>
	<ul>
	  <li>Initially a 16 bit little endian shift register (first bit shifts into MSB of 2nd byte).</li>
	  <li>After 16 bits are read, the register grows into a 32 bit little endian register.</li>
	  <li>After 32 bits of data are read, the next bits are put in a new shift register after the first full register, and the process starts again</li>
	</ul>
	<h3>Example</h3>
	<p>
	  This is how the 16 register is shifted, and overflows/transforms into the 32 bit register. In this case we are shifting in the number:
	  <code>abcdefghi</code> where each letter is a variable representing a bit (so we can track the bits more easily).
	</p>
	<p>
	  <code>
	  00000000 a0000000<br>
	  00000000 ba000000<br>
	  00000000 cba00000<br>
	  .....<br>
	  00000000 hgfedcba<br>
	  a0000000 ihgfedcb<br>
	  00000000 a0000000 ihgfedcb qponmlkj
	  </code>
	</p>
	<p>
	  The following will show the states of the return data buffer as data is shifter in. The data being read will be the following 32 bit value:
	</p>
	<p>
	  <code>00010110 11010100 11000000 10010011</code>
	</p>
	<p>
	  Here is the state of the return data over time as bits are shifted in.
	</p>
	<p>
	  <code>
	  4 bits   00:30 = 00000000 00110000<br>
	  5 bits   00:98 = 00000000 10011000<br>
	  8 bits   00:93 = 00000000 10010011<br>
	  9 bits   80:49 = 10000000 01001001<br>
	  15 bits  26:81 = 00100110 10000001<br>
	  16 bits  93:c0 = 10010011 11000000<br>
	  17 bits  00:80:49:60 = 00000000 10000000 01001001 01100000<br>
	  24 bits  00:93:c0:d4 = 00000000 10010011 11000000 11010100<br>
	  25 bits  80:49:60:6a = 10000000 01001001 01100000 01101010<br>
	  32 bits  93:c0:d4:16 = 10010011 11000000 11010100 00010110<br>
	  33 bits  93:c0:d4:16:00:00 = 10010011 11000000 11010100 00010110 00000000 00000000
	  </code>
	</p>
      </td>
    </tr>
    <tr>
      <td>Blink Green LED</td>
      <td>O</td>
      <td>0x2162</td>
      <td>0 for Stop<br>0x00F0 for Start</td>
      <td>0</td>
      <td>Available on the XLP firmware. Causes the Green LED to blink for debug or identification purposes.</td>
    </tr>

  </tbody>
</table>

<h3><a name="dv-specs" class="anchor" href="#dv-specs"><span class="octicon octicon-link"></span></a>Device Specifications</h3>
<p><a href="images/xpcu/schematic.png">Basic Schematic.</a></p>


<h3><a name="troubleshooting" class="anchor" href="#troubleshooting"><span class="octicon octicon-link"></span></a>Troubleshooting</h3>
<p><strong>If you want to check the version of firmware you have?</strong></p>
<pre>
  FW_VERSION_STRING=`grep ":0219B900" <strong>$PATH_TO_FIRMWARE_FILE`</strong>;
  FW_HEX_VERSION=${FW_VERSION_STRING:9:4};
  printf "%d" 0x$FW_HEX_VERSION;
</pre>

<p><strong>Green light solid after firmware load but device acting weird?</strong></p>
<p>The firmware hex file for this device can be found inside the linux install of ISE. There are several files with the same name at various locations, but ignore them and use the one at {Latest ISE path}/ISE_DS/ISE/bin/lin/xusb_emb.hex. If you use the wrong file, it will either refuse to load, or appear to load but not re-enumerate properly and behave oddly despite the green light on the device lighting up.</p>


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Adapt maintained by <a href="https://github.com/diamondman">diamondman</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>

<!--  LocalWords:  CPLD's TMS wvalue XPCU xa xYYZZ
 -->
